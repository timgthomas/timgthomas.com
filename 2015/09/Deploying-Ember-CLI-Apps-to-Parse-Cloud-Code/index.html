<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,viewport-fit=cover">
  <title>Deploying Ember CLI Apps to Parse Cloud Code · Tim G. Thomas</title>
  <link rel="alternate" href="http://feeds.feedburner.com/timgthomas" title="Tim G. Thomas" type="application/rss+xml">
  <link rel="icon" type="image/x-icon" href="/favicon.png">
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira+Sans:300,400,500,700,300italic,400italic,500italic,700italic|Fira+Mono">
  <link rel="stylesheet" href="/css/style.css">
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
  <header role="banner">
    <div class="container">
      <h1><a href="/">Tim <em>G</em> Thomas</a></h1>
      <input id="toggle-nav" type="checkbox">
      <nav>
        <a href="/">Blog</a>
        <a href="/projects">Projects</a>
        <a href="/speaking">Speaking</a>
      </nav>
    </div>
  </header>
  <aside>
    <div class="container">
      <p>I apply holistic design principles to make experiences both usable and beautiful.</p>
      <p class="social">
        <a class="social-github" href="https://github.com/timgthomas" target="_blank" rel="noopener">GitHub</a>
        <a class="social-codepen" href="https://codepen.io/TimGThomas" target="_blank" rel="noopener">CodePen</a>
        <a class="social-dribbble" href="https://dribbble.com/timgthomas" target="_blank" rel="noopener">Dribbble</a>
      </p>
    </div>
  </aside>
  <div role="main">
  <article>
    <header>
      <h1>Deploying Ember CLI Apps to Parse Cloud Code</h1>
      <p>2 September 2015</p>
    </header>
    <p>I’m a big fan of <a target="_blank" rel="noopener" href="https://parse.com/">Parse</a>: their backend-as-a-service works great for the type of apps I build, which generally have little to no “server” and communicate primarily through REST endpoints.</p>
<span id="more"></span>

<p>Just the other day, I discovered that their back-end can <a target="_blank" rel="noopener" href="http://blog.parse.com/announcements/goodbye-web-servers-hello-parse-hosting/">host static files</a>, meaning I could move my deployed <a target="_blank" rel="noopener" href="http://emberjs.com/">Ember</a> apps away from services like <a target="_blank" rel="noopener" href="http://aws.amazon.com/s3/">S3</a> or <a target="_blank" rel="noopener" href="https://www.heroku.com/">Heroku</a>, thus simplifying (and cheapening) my deployments. Getting an <a target="_blank" rel="noopener" href="http://www.ember-cli.com/">Ember CLI</a> app to run on Parse was a little less than frictionless, though, and, in this post, we’ll look at how to manage it.</p>
<p>To get started, you’ll need:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.parse.com/signup">A Parse account</a> (there’s a free option) and <a target="_blank" rel="noopener" href="https://parse.com/account/keys">Account Key</a>,</li>
<li><a target="_blank" rel="noopener" href="https://parse.com/apps">A Parse application</a>, and</li>
<li>An Ember CLI app.</li>
</ul>
<h2 id="But-First-a-Caveat"><a href="#But-First-a-Caveat" class="headerlink" title="But First, a Caveat"></a>But First, a Caveat</h2><p>To be fair, deploying static files to Parse (such as those generated by Ember CLI) is quite simple. The Parse team provides a <a target="_blank" rel="noopener" href="https://parse.com/docs/js/guide#command-line">command line tool</a> to deploy your code and assets, and it works well. What makes deploying Ember apps tricky has to do with <a target="_blank" rel="noopener" href="http://guides.emberjs.com/v2.0.0/routing/specifying-the-location-api/">Ember’s URLs</a>.</p>
<p>By default, Ember CLI apps use a browser’s history API, which gives you URLs like <code>your-app.com/photos/1</code>. Here’s the issue: if a user navigates directly to that URL, most web servers will look for either static files or a defined route to serve, neither of which we’ll have after deploying this app.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -s -w <span class="string">&quot;%&#123;http_code&#125;&quot;</span> http://your-app.com/photos/1 -o /dev/null</span><br><span class="line">&gt; 404 <span class="comment"># Ruh roh.</span></span><br></pre></td></tr></table></figure>

<p>To fix this, we can tell Ember CLI to use “hash”-based URLs instead (like <code>your-app.com/#/photos/1</code>), which we’ll see how to do momentarily. This tells the server to load the root document, and Ember can then step in to figure out what route you’re looking at based on what’s past the “hash” symbol.</p>
<p>Now that’s out of the way, let’s get started deploying our Ember CLI app to Parse.</p>
<h2 id="The-Easy-Way"><a href="#The-Easy-Way" class="headerlink" title="The Easy Way"></a>The Easy Way</h2><p><strong>Update Ember CLI’s location type.</strong> We now know that history-based URLs will break when Parse serves the app from static files, so let’s change our app to use hashes instead: in <code>config/environment.js</code>, simply change the <code>locationType</code> property from <code>&#39;auto&#39;</code> to <code>&#39;hash&#39;</code>.</p>
<p><strong>Get your project Parse-ready.</strong> The fastest way to do this is to create a new Parse app using their command line tool. From there, you can either copy the files you need into an existing project, or create a new Ember CLI project inline. Using the Parse CLI, run <code>parse generate</code> and answer its questions. You’ll see a few files in there that you’ll need in your Ember app:</p>
<ul>
<li>The <code>/cloud</code> folder contains any custom server code your Parse app needs. The Parse CLI generates some default code in <code>main.js</code>…you can take it or leave it, but you’ll need the <code>cloud</code> directory either way.</li>
<li>The <code>/public</code> folder is where your compiled Ember app will belong. You don’t need to copy this over; we’ll make our own.</li>
<li><code>.parse.local</code> contains some properties that tell Parse to which app this code will belong. <em><strong>Warning:</strong> since this file contains your application’s unique key, make sure you don’t check it in to public source control. The <a target="_blank" rel="noopener" href="https://github.com/fivetanley/ember-cli-dotenv"><code>ember-cli-dotenv</code></a> library can help with this.</em></li>
<li><code>.parse.project</code> tells Parse what version of its SDK to use. This one’s safe to stick on GitHub. :)</li>
</ul>
<p>For more details, check out the <a href="(https://parse.com/apps/quickstart#cloud_code/unix">Parse documentation on the subject</a>.</p>
<p><strong>Deploy!</strong> This step requires a bit more prep. What we need is to compile the Ember app into a <code>public</code> directory, then copy the Parse files from the previous step, then tell the Parse CLI to perform the deploy. I use a bash script for this, but be warned: I’m not a bash expert by any means, so feedback is definitely appreciated.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Compile the Ember app.</span></span><br><span class="line">ember build -prod -o dist/public</span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy Parse files and any Cloud Code.</span></span><br><span class="line">cp .parse.project dist/.parse.project</span><br><span class="line">cp .parse.local dist/.parse.local</span><br><span class="line">cp -R cloud dist/cloud</span><br><span class="line"></span><br><span class="line"><span class="comment"># Deploy to Parse.</span></span><br><span class="line"><span class="built_in">cd</span> dist</span><br><span class="line">parse deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clean up after we finish.</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">rm -rf dist</span><br></pre></td></tr></table></figure>

<p>Just run the bash script with <code>sh your-file-name.sh</code>, or maybe set it as an <a target="_blank" rel="noopener" href="https://docs.npmjs.com/cli/run-script">npm package script</a>.</p>
<h2 id="The-Hard-er-Way"><a href="#The-Hard-er-Way" class="headerlink" title="The Hard(-er) Way"></a>The Hard(-er) Way</h2><p>At this point, you should have a fully-operational Ember app running on Parse…but we can do better. Let’s change our deploy process so we can use those history-based URLs.</p>
<p><strong>Reset things.</strong> To start, change your app’s <code>locationType</code> parameter (in <code>config/environment.js</code>) back to <code>&#39;auto&#39;</code>. No use in sticking with hash-based URLs anymore!</p>
<p><strong>Make a mini node app.</strong> We’ll need to tell Parse to always serve up the root document (located at <code>public/index.html</code>) to any and all requests so that Ember can take over routing. Fortunately, this is easily accomplished by giving Parse a <a target="_blank" rel="noopener" href="http://blog.parse.com/announcements/building-parse-web-apps-with-the-express-web-framework/">simple node app</a> that it will run alongside serving static files. The following code is from <a target="_blank" rel="noopener" href="https://twitter.com/erikch">Erik Hanchett</a>‘s great blog post on <a target="_blank" rel="noopener" href="http://www.programwitherik.com/setup-your-ember-project-with-node/">serving Ember apps from Express</a>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;*&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Send the contents of &quot;public/index.html&quot;.</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen();</span><br></pre></td></tr></table></figure>

<p>Parse starts by looking for files in the <code>public</code> directory before it will run this simple server, so we won’t need to worry about not handling routes for static assets like CSS and JavaScript. From the <a target="_blank" rel="noopener" href="https://parse.com/docs/js/guide#hosting-static-content">Parse documentation</a>:</p>
<blockquote>
<p>When a request goes to a URL of your subdomain, Parse will first look for a matching file in the <code>public</code> directory. If there is no match, then Parse will invoke any Express request handlers that you have registered in Cloud Code.</p>
</blockquote>
<p>To <a target="_blank" rel="noopener" href="https://parse.com/docs/js/guide#hosting-creating-a-web-app">tell Parse about this node server</a>, have your app’s <code>main.js</code> file import it with <code>require(&#39;cloud/app.js&#39;);</code> on the first line.</p>
<p><strong>Send down the root file.</strong> Unfortunately, Parse’s node implementation lacks certain features (like Express’s <a target="_blank" rel="noopener" href="http://expressjs.com/api.html#res"><code>Response</code></a> object’s <code>sendFile()</code> function) that would make sending down a static file trivial. Instead, I’m using a bit of a hack: in the deploy script, make the root file an EJS template, then tell the node app to render it (something the Parse node binary <a target="_blank" rel="noopener" href="https://parse.com/docs/js/guide#hosting-rendering-templates"><em>can</em> do</a>):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.set(<span class="string">&#x27;views&#x27;</span>, <span class="string">&#x27;cloud/views&#x27;</span>);</span><br><span class="line">app.set(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;ejs&#x27;</span>);</span><br><span class="line">app.use(express.bodyParser());</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;*&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.render(<span class="string">&#x27;index&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen();</span><br></pre></td></tr></table></figure>

<p>Here’s the new part of the bash script that does that:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create the &#x27;views&#x27; directory.</span></span><br><span class="line">mkdir -p dist/cloud/views</span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy the root file.</span></span><br><span class="line">cp dist/public/index.html dist/cloud/views/index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rename it to &#x27;*.ejs&#x27;</span></span><br><span class="line">mv dist/cloud/views/index.html dist/cloud/views/index.ejs</span><br></pre></td></tr></table></figure>

<p><strong>Deploy! Again!</strong> With the build script modified, we’re ready to deploy again! This time, our script will also copy the <code>index.html</code> file into the <code>cloud/views</code> folder so our mini-node app can serve it. All that’s left is to visit your Parse app and see if everything works correctly. If not…well, Parse has some great <a target="_blank" rel="noopener" href="https://parse.com/docs/js/guide#command-line-reading-the-logs">logging tools</a>!</p>
<hr>
<p>Even with the workaround for Ember’s history-based URLs, I’m thrilled with how easy it is to deploy an Ember CLI app to Parse. If you’re already a Parse user, or have been looking for an excuse to give it a try, why not try your hand at deploying an Ember app? If you run into any issues, or have suggestions for ways to streamline this process, share them in the comments!</p>

    <script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "@id": "/2015/09/Deploying-Ember-CLI-Apps-to-Parse-Cloud-Code/",
    "headline": "Deploying Ember CLI Apps to Parse Cloud Code",
    "datePublished": "Wed Sep 02 2015 00:00:00 GMT-0500",
    "image": "http://timgthomas.com/images/headshot.png"
  }
</script>

  </article>
  <nav>
    <span class="post-nav-next">
      
        <a href="/2015/07/installing-ember-cli-on-windows/">Installing Ember CLI on Windows</a>
      
    </span>
    <span class="post-nav-prev">
      
        <a href="/2015/09/the-making-of-stateful-css/">The Making of “You Might Not Need JavaScript”</a>
      
    </span>
  </nav>
  
  <h2>Comments</h2>
  <div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.title = 'Deploying Ember CLI Apps to Parse Cloud Code';
      this.page.url = 'http://timgthomas.com/2015/09/Deploying-Ember-CLI-Apps-to-Parse-Cloud-Code/';
      this.page.identifier = '2015/09/Deploying-Ember-CLI-Apps-to-Parse-Cloud-Code/index.html';
    };

    (function() {
      var d = document, s = d.createElement('script');
      s.src = 'https://timgthomas.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>


</div>

  <p id="copyright">&copy; Tim G. Thomas</p>
  
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-49175000-1', 'auto');
  ga('send', 'pageview');
</script>
<script defer data-domain="timgthomas.com" src="https://plausible.io/js/plausible.js"></script>

  
</body>
</html>
